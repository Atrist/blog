<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>从前序与中序遍历序列构造二叉树 | Atrist</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="刷算法,向前进">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b5c0c7a6.css" as="style"><link rel="preload" href="/blog/assets/js/app.fc512097.js" as="script"><link rel="preload" href="/blog/assets/js/14.2d6cb8c4.js" as="script"><link rel="preload" href="/blog/assets/js/4.6ca56664.js" as="script"><link rel="preload" href="/blog/assets/js/63.dd721552.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.6166f1e1.js"><link rel="prefetch" href="/blog/assets/js/100.f02e0fff.js"><link rel="prefetch" href="/blog/assets/js/101.7e6efb5f.js"><link rel="prefetch" href="/blog/assets/js/102.e43dc80a.js"><link rel="prefetch" href="/blog/assets/js/103.b537cf49.js"><link rel="prefetch" href="/blog/assets/js/104.559cea59.js"><link rel="prefetch" href="/blog/assets/js/105.7176bb58.js"><link rel="prefetch" href="/blog/assets/js/106.c2a38109.js"><link rel="prefetch" href="/blog/assets/js/107.b3f4bf85.js"><link rel="prefetch" href="/blog/assets/js/108.28cd766f.js"><link rel="prefetch" href="/blog/assets/js/109.220eeaea.js"><link rel="prefetch" href="/blog/assets/js/11.69c987e3.js"><link rel="prefetch" href="/blog/assets/js/110.9ca9e6ec.js"><link rel="prefetch" href="/blog/assets/js/111.e99c0d2a.js"><link rel="prefetch" href="/blog/assets/js/112.a5cb4505.js"><link rel="prefetch" href="/blog/assets/js/113.6c3719e2.js"><link rel="prefetch" href="/blog/assets/js/114.a47704bf.js"><link rel="prefetch" href="/blog/assets/js/115.59228c92.js"><link rel="prefetch" href="/blog/assets/js/116.6dc3887b.js"><link rel="prefetch" href="/blog/assets/js/117.72856396.js"><link rel="prefetch" href="/blog/assets/js/118.bb57d12a.js"><link rel="prefetch" href="/blog/assets/js/119.4f4835b4.js"><link rel="prefetch" href="/blog/assets/js/12.fe8b84b1.js"><link rel="prefetch" href="/blog/assets/js/120.e89199c1.js"><link rel="prefetch" href="/blog/assets/js/121.3de39996.js"><link rel="prefetch" href="/blog/assets/js/122.899d427e.js"><link rel="prefetch" href="/blog/assets/js/123.0cc01039.js"><link rel="prefetch" href="/blog/assets/js/124.742ababf.js"><link rel="prefetch" href="/blog/assets/js/125.be96abb7.js"><link rel="prefetch" href="/blog/assets/js/13.c969cf79.js"><link rel="prefetch" href="/blog/assets/js/15.9c009213.js"><link rel="prefetch" href="/blog/assets/js/16.06cdfe10.js"><link rel="prefetch" href="/blog/assets/js/17.d298a703.js"><link rel="prefetch" href="/blog/assets/js/18.8baa3cc6.js"><link rel="prefetch" href="/blog/assets/js/19.d5211f5e.js"><link rel="prefetch" href="/blog/assets/js/20.1b669459.js"><link rel="prefetch" href="/blog/assets/js/21.27cdf63a.js"><link rel="prefetch" href="/blog/assets/js/22.67468f2c.js"><link rel="prefetch" href="/blog/assets/js/23.64c294b4.js"><link rel="prefetch" href="/blog/assets/js/24.df7359a6.js"><link rel="prefetch" href="/blog/assets/js/25.eba32b86.js"><link rel="prefetch" href="/blog/assets/js/26.8f023305.js"><link rel="prefetch" href="/blog/assets/js/27.3b91f996.js"><link rel="prefetch" href="/blog/assets/js/28.4716235d.js"><link rel="prefetch" href="/blog/assets/js/29.4a9272c8.js"><link rel="prefetch" href="/blog/assets/js/30.bdcfc505.js"><link rel="prefetch" href="/blog/assets/js/31.60f6ab0e.js"><link rel="prefetch" href="/blog/assets/js/32.c5cdee8a.js"><link rel="prefetch" href="/blog/assets/js/33.6fb6c541.js"><link rel="prefetch" href="/blog/assets/js/34.e048405c.js"><link rel="prefetch" href="/blog/assets/js/35.3f8fb131.js"><link rel="prefetch" href="/blog/assets/js/36.4f10cc9c.js"><link rel="prefetch" href="/blog/assets/js/37.6f86aa90.js"><link rel="prefetch" href="/blog/assets/js/38.21ff9674.js"><link rel="prefetch" href="/blog/assets/js/39.e49553c5.js"><link rel="prefetch" href="/blog/assets/js/40.ec0e6570.js"><link rel="prefetch" href="/blog/assets/js/41.e0c0078f.js"><link rel="prefetch" href="/blog/assets/js/42.cf1646fc.js"><link rel="prefetch" href="/blog/assets/js/43.94a55666.js"><link rel="prefetch" href="/blog/assets/js/44.124ee862.js"><link rel="prefetch" href="/blog/assets/js/45.5a130613.js"><link rel="prefetch" href="/blog/assets/js/46.81bf5673.js"><link rel="prefetch" href="/blog/assets/js/47.df156b54.js"><link rel="prefetch" href="/blog/assets/js/48.33a4a52a.js"><link rel="prefetch" href="/blog/assets/js/49.d8a9a4a3.js"><link rel="prefetch" href="/blog/assets/js/5.f1d3a1f4.js"><link rel="prefetch" href="/blog/assets/js/50.4c448bc4.js"><link rel="prefetch" href="/blog/assets/js/51.74116729.js"><link rel="prefetch" href="/blog/assets/js/52.21087215.js"><link rel="prefetch" href="/blog/assets/js/53.d09cb8d1.js"><link rel="prefetch" href="/blog/assets/js/54.64be5ef0.js"><link rel="prefetch" href="/blog/assets/js/55.178fac91.js"><link rel="prefetch" href="/blog/assets/js/56.5422fa80.js"><link rel="prefetch" href="/blog/assets/js/57.cb8de138.js"><link rel="prefetch" href="/blog/assets/js/58.5a3c0f5b.js"><link rel="prefetch" href="/blog/assets/js/59.9ef2a85c.js"><link rel="prefetch" href="/blog/assets/js/6.dc18737d.js"><link rel="prefetch" href="/blog/assets/js/60.275481b7.js"><link rel="prefetch" href="/blog/assets/js/61.08cd91f7.js"><link rel="prefetch" href="/blog/assets/js/62.e62cd517.js"><link rel="prefetch" href="/blog/assets/js/64.e6fe875e.js"><link rel="prefetch" href="/blog/assets/js/65.30ee5b39.js"><link rel="prefetch" href="/blog/assets/js/66.df1d20a7.js"><link rel="prefetch" href="/blog/assets/js/67.55c76a74.js"><link rel="prefetch" href="/blog/assets/js/68.a8730456.js"><link rel="prefetch" href="/blog/assets/js/69.5f8bcd16.js"><link rel="prefetch" href="/blog/assets/js/7.7ba720da.js"><link rel="prefetch" href="/blog/assets/js/70.efab5e00.js"><link rel="prefetch" href="/blog/assets/js/71.9dedf7f6.js"><link rel="prefetch" href="/blog/assets/js/72.f7d77bf6.js"><link rel="prefetch" href="/blog/assets/js/73.a9358b78.js"><link rel="prefetch" href="/blog/assets/js/74.dc027ed2.js"><link rel="prefetch" href="/blog/assets/js/75.724f762e.js"><link rel="prefetch" href="/blog/assets/js/76.5ab4fa66.js"><link rel="prefetch" href="/blog/assets/js/77.627f67dd.js"><link rel="prefetch" href="/blog/assets/js/78.aac8a4fd.js"><link rel="prefetch" href="/blog/assets/js/79.c76e7f0c.js"><link rel="prefetch" href="/blog/assets/js/8.e8e86bb7.js"><link rel="prefetch" href="/blog/assets/js/80.62bbdf78.js"><link rel="prefetch" href="/blog/assets/js/81.787cfe3d.js"><link rel="prefetch" href="/blog/assets/js/82.6171f91f.js"><link rel="prefetch" href="/blog/assets/js/83.52d1321e.js"><link rel="prefetch" href="/blog/assets/js/84.684d1171.js"><link rel="prefetch" href="/blog/assets/js/85.3df9991a.js"><link rel="prefetch" href="/blog/assets/js/86.88d6d91a.js"><link rel="prefetch" href="/blog/assets/js/87.ba67e913.js"><link rel="prefetch" href="/blog/assets/js/88.5b59aea1.js"><link rel="prefetch" href="/blog/assets/js/89.5ebc72cf.js"><link rel="prefetch" href="/blog/assets/js/9.0d9def4a.js"><link rel="prefetch" href="/blog/assets/js/90.afacf7b7.js"><link rel="prefetch" href="/blog/assets/js/91.3ec83dc3.js"><link rel="prefetch" href="/blog/assets/js/92.9eac7f04.js"><link rel="prefetch" href="/blog/assets/js/93.c2c1ce3c.js"><link rel="prefetch" href="/blog/assets/js/94.0c8f05a5.js"><link rel="prefetch" href="/blog/assets/js/95.e85c4505.js"><link rel="prefetch" href="/blog/assets/js/96.074deece.js"><link rel="prefetch" href="/blog/assets/js/97.a2ed6129.js"><link rel="prefetch" href="/blog/assets/js/98.7104bda7.js"><link rel="prefetch" href="/blog/assets/js/99.cb8d02e4.js"><link rel="prefetch" href="/blog/assets/js/vendors~flowchart.122ff8c9.js"><link rel="prefetch" href="/blog/assets/js/vuejs-paginate.e2b71e33.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b5c0c7a6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/blog/" class="nav-link home-link">Atrist </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/blog/tag/" class="nav-link">Tags</a></li><li class="nav-item"><a href="/blog/1970/01/01/resume/" class="nav-link">Resume</a></li><li class="nav-item"><a href="https://github.com/Atrist" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/blog/" class="nav-link mobile-home-link">Atrist </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/blog/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/blog/tag/" class="nav-link">Tags</a></li><li class="mobile-nav-item"><a href="/blog/1970/01/01/resume/" class="nav-link">Resume</a></li><li class="mobile-nav-item"><a href="https://github.com/Atrist" target="_blank" rel="noopener noreferrer" class="nav-link external">Github</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        从前序与中序遍历序列构造二叉树
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">Atrist</span> <!----></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-12-14T00:00:00.000Z">
      Mon Dec 14 2020
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/blog/tag/leetcode" data-v-42ccfcd5><span data-v-42ccfcd5>leetcode</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ol><li><a href="https://leetcode-cn.com/leetbook/detail/top-interview-questions-medium/" target="_blank" rel="noopener noreferrer">leetcode 中级算法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/" target="_blank" rel="noopener noreferrer">从前序与中序遍历序列构造二叉树<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ol> <h2 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="header-anchor">#</a> 从前序与中序遍历序列构造二叉树</h2> <p>根据一棵树的前序遍历与中序遍历构造二叉树。</p> <h3 id="注意"><a href="#注意" class="header-anchor">#</a> 注意:</h3> <p>你可以假设树中没有重复的元素。</p> <h3 id="例如"><a href="#例如" class="header-anchor">#</a> 例如</h3> <p>给出</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>前序遍历 preorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3,9</span>,20,15,7<span class="token punctuation">]</span>
中序遍历 inorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9,3</span>,15,20,7<span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>返回如下的二叉树：</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>    <span class="token number">3</span>
   / <span class="token punctuation">\</span>
  <span class="token number">9</span>  <span class="token number">20</span>
    /  <span class="token punctuation">\</span>
   <span class="token number">15</span>   <span class="token number">7</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>二叉树前序遍历的顺序为：</p> <ul><li>先遍历根节点；</li> <li>随后递归地遍历左子树；</li> <li>最后递归地遍历右子树。</li></ul> <p>二叉树中序遍历的顺序为：</p> <ul><li>先递归地遍历左子树；</li> <li>随后遍历根节点；</li> <li>最后递归地遍历右子树。</li></ul> <p>在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。</p> <h2 id="方法一-递归"><a href="#方法一-递归" class="header-anchor">#</a> 方法一：递归</h2> <h3 id="思路"><a href="#思路" class="header-anchor">#</a> 思路</h3> <p>对于任意一颗树而言，前序遍历的形式总是</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span> 根节点, <span class="token punctuation">[</span>左子树的前序遍历结果<span class="token punctuation">]</span>, <span class="token punctuation">[</span>右子树的前序遍历结果<span class="token punctuation">]</span> <span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token punctuation">[</span> <span class="token punctuation">[</span>左子树的中序遍历结果<span class="token punctuation">]</span>, 根节点, <span class="token punctuation">[</span>右子树的中序遍历结果<span class="token punctuation">]</span> <span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>只要我们在中序遍历中<strong>定位</strong>到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有<strong>左右括号</strong>进行定位。</p> <p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p> <h3 id="细节"><a href="#细节" class="header-anchor">#</a> 细节</h3> <p>在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希映射（HashMap）来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。</p> <p>下面的代码给出了详细的注释。</p> <h3 id="代码"><a href="#代码" class="header-anchor">#</a> 代码</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">const</span> <span class="token function-variable function">myBuildTree</span>  <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> preorder_left<span class="token punctuation">,</span> preorder_right<span class="token punctuation">,</span> inorder_left<span class="token punctuation">,</span> inorder_right</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>preorder_left <span class="token operator">&gt;</span> preorder_right<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">null</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 前序遍历中的第一个就是根节点</span>
        <span class="token keyword">let</span> preorder_root <span class="token operator">=</span>  preorder_left
        <span class="token comment">// 在中序遍历中定位根节点</span>
        <span class="token keyword">let</span> inorder_root <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preorder_root<span class="token punctuation">]</span><span class="token punctuation">)</span>

        <span class="token comment">// 先把 根节点建立出来</span>
        <span class="token keyword">let</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span>preorder_root<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token comment">// 得到左子树中的节点数目</span>
        <span class="token keyword">let</span> size_left_subtree <span class="token operator">=</span> inorder_root <span class="token operator">-</span> inorder_left
        <span class="token comment">// 递归遍历左子树, 并连接到根节点</span>
        <span class="token comment">// 先序遍历 中 [ 从 左边界 +1 开始的 size_left_subtree] 个 元素就对应了中序遍历「从 左边界 开始到 根节点定位-1」的元素</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> preorder_left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> preorder_left <span class="token operator">+</span>size_left_subtree<span class="token punctuation">,</span>inorder_left<span class="token punctuation">,</span>inorder_root<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span>

        <span class="token comment">// 递归地构造右子树, 并连接到根节点</span>
        <span class="token comment">// 先序遍历中 「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> preorder_left <span class="token operator">+</span> size_left_subtree<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> preorder_right<span class="token punctuation">,</span>inorder_root<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>inorder_right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> node
    <span class="token punctuation">}</span>
    <span class="token keyword">let</span> length <span class="token operator">=</span> preorder<span class="token punctuation">.</span>length
    
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>inorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">myBuildTree</span><span class="token punctuation">(</span>preorder<span class="token punctuation">,</span> inorder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><h3 id="复杂度分析"><a href="#复杂度分析" class="header-anchor">#</a> 复杂度分析</h3> <ul><li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li> <li>空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(n) 的空间存储哈希映射，以及 O(h)（其中 h 是树的高度）的空间表示递归时栈空间。这里 h &lt; n，所以总空间复杂度为 O(n)。</li></ul> <h2 id="方法二-迭代"><a href="#方法二-迭代" class="header-anchor">#</a> 方法二：迭代</h2> <h3 id="思路-2"><a href="#思路-2" class="header-anchor">#</a> 思路</h3> <p>迭代法是一种非常巧妙的实现方法。</p> <p>对于前序遍历中的任意两个连续节点 u 和 v，根据前序遍历的流程，我们可以知道 u 和 v 只有两种可能的关系：</p> <ul><li>v 是 u 的左儿子。这是因为在遍历到 u 之后，下一个遍历的节点就是 u 的左儿子，即   v；</li> <li>u 没有左儿子，并且 v 是 u 的某个祖先节点（或者 u 本身）的右儿子。如果 u 没有左儿子，那么下一个遍历的节点就是 u 的右儿子。如果 u 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 u 不在它的右儿子的子树中）的节点 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">u_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>，那么 v 就是 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>a</mi></msub></mrow><annotation encoding="application/x-tex">u_a</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">u</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">a</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>的右儿子。</li></ul> <p>第二种关系看上去有些复杂。我们举一个例子来说明其正确性，并在例子中给出我们的迭代算法。</p> <h3 id="例子"><a href="#例子" class="header-anchor">#</a> 例子</h3> <p>我们以树</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>        <span class="token number">3</span>
       / <span class="token punctuation">\</span>
      <span class="token number">9</span>  <span class="token number">20</span>
     /  /  <span class="token punctuation">\</span>
    <span class="token number">8</span>  <span class="token number">15</span>   <span class="token number">7</span>
   / <span class="token punctuation">\</span>
  <span class="token number">5</span>  <span class="token number">10</span>
 /
<span class="token number">4</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>为例，它的前序遍历和中序遍历分别为</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>preorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span>, <span class="token number">9</span>, <span class="token number">8</span>, <span class="token number">5</span>, <span class="token number">4</span>, <span class="token number">10</span>, <span class="token number">20</span>, <span class="token number">15</span>, <span class="token number">7</span><span class="token punctuation">]</span>
inorder <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span>, <span class="token number">5</span>, <span class="token number">8</span>, <span class="token number">10</span>, <span class="token number">9</span>, <span class="token number">3</span>, <span class="token number">15</span>, <span class="token number">20</span>, <span class="token number">7</span><span class="token punctuation">]</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>我们用一个栈 <code>stack</code> 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 <code>index</code> 指向中序遍历的某个位置，初始值为 <code>0</code>。<code>index</code> 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的，它的作用在下面的过程中会有所体现。</p> <p>首先我们将根节点 3 入栈，再初始化 <code>index</code> 所指向的节点为 4，随后对于前序遍历中的每个节点，我们依次判断它是栈顶节点的左儿子，还是栈中某个节点的右儿子。</p> <ul><li><p>我们遍历 <code>9</code>。<code>9</code> 一定是栈顶节点 <code>3</code> 的左儿子。我们使用反证法，假设 <code>9</code> 是 <code>3</code> 的右儿子，那么 <code>3</code> 没有左儿子，<code>index</code> 应该恰好指向 <code>3</code>，但实际上为 <code>4</code>，因此产生了矛盾。所以我们将 <code>9</code> 作为 <code>3</code> 的左儿子，并将 <code>9</code> 入栈。</p> <ul><li><code>stack = [3, 9]</code></li> <li><code>index -&gt; inorder[0] = 4</code></li></ul></li> <li><p>我们遍历 <code>8</code>，<code>5</code> 和 <code>4</code>。同理可得它们都是上一个节点（栈顶节点）的左儿子，所以它们会依次入栈。</p> <ul><li><code>stack = [3, 9, 8, 5, 4]</code></li> <li><code>index -&gt; inorder[0] = 4</code></li></ul></li> <li><p>我们遍历 <code>10</code>，这时情况就不一样了。我们发现 <code>index</code> 恰好指向当前的栈顶节点 <code>4</code>，也就是说 <code>4</code> 没有左儿子，那么 <code>10</code> 必须为栈中某个节点的右儿子。那么如何找到这个节点呢？栈中的节点的顺序和它们在前序遍历中出现的顺序是一致的，而且每一个节点的右儿子都还没有被遍历过，<strong>那么这些节点的顺序和它们在中序遍历中出现的顺序一定是相反的。</strong></p> <blockquote><p>这是因为栈中的任意两个相邻的节点，前者都是后者的某个祖先。并且我们知道，栈中的任意一个节点的右儿子还没有被遍历过，说明后者一定是前者左儿子的子树中的节点，那么后者就先于前者出现在中序遍历中。</p></blockquote></li></ul> <p>因此我们可以把 <code>index</code> 不断向右移动，并与栈顶节点进行比较。如果 <code>index</code> 对应的元素恰好等于栈顶节点，那么说明我们在中序遍历中找到了栈顶节点，所以将 <code>index</code> 增加 <code>1</code> 并弹出栈顶节点，直到 <code>index</code> 对应的元素不等于栈顶节点。按照这样的过程，我们弹出的最后一个节点 <code>x</code> 就是 <code>10</code> 的双亲节点，<strong>这是因为 <code>10</code> 出现在了 x 与 x 在栈中的下一个节点的中序遍历之间</strong>，因此 10 就是 x 的右儿子。</p> <p>回到我们的例子，我们会依次从栈顶弹出 4，5 和 8，并且将 <code>index</code> 向右移动了三次。我们将 10 作为最后弹出的节点 8 的右儿子，并将 10 入栈。</p> <ul><li><code>stack = [3, 9, 10]</code></li> <li><code>index -&gt; inorder[3] = 10</code></li></ul> <p>我们遍历 20。同理，index 恰好指向当前栈顶节点 10，那么我们会依次从栈顶弹出 10，9 和 3，并且将 index 向右移动了三次。我们将 20 作为最后弹出的节点 3 的右儿子，并将 20 入栈。</p> <ul><li><code>stack = [20]</code></li> <li><code>index -&gt; inorder[6] = 15</code></li></ul> <p>我们遍历 15，将 15 作为栈顶节点 20 的左儿子，并将 15 入栈。</p> <ul><li><code>stack = [20, 15]</code></li> <li><code>index -&gt; inorder[6] = 15</code></li></ul> <p>我们遍历 7。index 恰好指向当前栈顶节点 15，那么我们会依次从栈顶弹出 15 和 20，并且将 index 向右移动了两次。我们将 7 作为最后弹出的节点 20 的右儿子，并将 7 入栈。</p> <ul><li><code>stack = [7]</code></li> <li><code>index -&gt; inorder[8] = 7</code></li></ul> <p>此时遍历结束，我们就构造出了正确的二叉树。</p> <h3 id="算法"><a href="#算法" class="header-anchor">#</a> 算法</h3> <p>我们归纳出上述例子中的算法流程：</p> <ul><li><p>我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点；</p></li> <li><p>我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 <code>index</code> 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 <code>index</code>，并将当前节点作为最后一个弹出的节点的右儿子；如果 <code>index</code> 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；</p></li> <li><p>无论是哪一种情况，我们最后都将当前的节点入栈。</p></li></ul> <p>最后得到的二叉树即为答案。</p> <h3 id="代码-2"><a href="#代码-2" class="header-anchor">#</a> 代码</h3> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * @param {number[]} preorder
 * @param {number[]} inorder
 * @return {TreeNode}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">buildTree</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">preorder<span class="token punctuation">,</span> inorder</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>preorder <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> preorder<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorder<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> inorderIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> preorder<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> preorderVal <span class="token operator">=</span> preorder<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 查看栈顶元素</span>
        <span class="token keyword">let</span> node <span class="token operator">=</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>val <span class="token operator">!==</span> inorder<span class="token punctuation">[</span>inorderIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorderVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>
                <span class="token operator">!</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
                stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>val <span class="token operator">===</span> inorder<span class="token punctuation">[</span>inorderIndex<span class="token punctuation">]</span>
            <span class="token punctuation">)</span> <span class="token punctuation">{</span>
                node <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                inorderIndex<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>preorderVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> root
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="header-anchor">#</a> 复杂度分析</h3> <ul><li>时间复杂度：O(n)，其中 n 是树中的节点个数。</li> <li>空间复杂度：O(n)，除去返回的答案需要的 O(n) 空间之外，我们还需要使用 O(h)（其中 h 是树的高度）的空间存储栈。这里 h &lt; n，所以（在最坏情况下）总空间复杂度为 O(n)。</li></ul></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#参考资料" title="参考资料">参考资料</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#从前序与中序遍历序列构造二叉树" title="从前序与中序遍历序列构造二叉树">从前序与中序遍历序列构造二叉树</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#注意" title="注意:">注意:</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#例如" title="例如">例如</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#前言" title="前言">前言</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#方法一-递归" title="方法一：递归">方法一：递归</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#思路" title="思路">思路</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#细节" title="细节">细节</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#代码" title="代码">代码</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#复杂度分析" title="复杂度分析">复杂度分析</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#方法二-迭代" title="方法二：迭代">方法二：迭代</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#思路-2" title="思路">思路</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#例子" title="例子">例子</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#算法" title="算法">算法</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#代码-2" title="代码">代码</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#复杂度分析-2" title="复杂度分析">复杂度分析</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8><li class="contact-item" data-v-3d9deeb8><a href="https://github.com/Atrist" target="_blank" rel="noopener noreferrer" class="nav-link external" data-v-3d9deeb8><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github" data-v-3d9deeb8><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22" data-v-3d9deeb8></path></svg>
          
        </a></li></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8><li class="copyright-item" data-v-3d9deeb8>Copyright © 2018-present</li></ul></div></footer></div><div class="global-ui"><!----><div class="cat-container" data-v-a13867c0><canvas id="vuepress-cat" width="280" height="250" class="live2d" data-v-a13867c0></canvas></div><div class="vuepress-eqn"></div><span class="vuepress-eq"></span></div></div>
    <script src="/blog/assets/js/app.fc512097.js" defer></script><script src="/blog/assets/js/14.2d6cb8c4.js" defer></script><script src="/blog/assets/js/4.6ca56664.js" defer></script><script src="/blog/assets/js/63.dd721552.js" defer></script>
  </body>
</html>
